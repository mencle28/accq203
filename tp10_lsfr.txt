print("""\
# *************************************************************************** #
# *************************************************************************** #
# TP10 : INVARIANTS DE SIMILITUDE ET LFSR                                     #
# *************************************************************************** #
# *************************************************************************** #
""")

# CONSIGNES
#
# Les seules lignes a modifier sont annoncee par "Code pour l'exercice"
# indique en commmentaire et son signalees
# Ne changez pas le nom des variables
#
# CONSEILS
#
# Ce modele vous sert a restituer votre travail. Il est deconseille d'ecrire
# une longue suite d'instruction et de debugger ensuite. Il vaut mieux tester
# le code que vous produisez ligne apres ligne, afficher les resultats et
# controler que les objets que vous definissez sont bien ceux que vous attendez.
#
# Vous devez verifier votre code en le testant, y compris par des exemples que
# vous aurez fabrique vous-meme.
#


reset()
print("""\
# ****************************************************************************
# INVARIANTS DE SIMILITUDE DONE
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

PolQQ.<x>=PolynomialRing(QQ)



M1 =  matrix(QQ,[[-1841, -10363, 22304, 108021, -243809 ],
[1366, 7695, -16535, -80130, 180869 ],[
-1072, -6088, 13069, 63408, -143144 ],[
506, 2951, -6298, -30700, 69343 ],[
82, 502, -1061, -5214, 11788]])

M2 = matrix(QQ,[[570, 1652, -8251, 3807, 34007 ],[
-178, -522, 2666, -1196, -10988 ],[
540, 1573, -7866, 3622, 32430 ],[
-42, -118, 580, -275, -2387 ],[
135, 393, -1967, 905, 8109]])

M3 = matrix(QQ,[[64, -300, 924, -228, 3168 ],[
-80, 404, -1232, 304, -4224 ],[
35, -175, 543, -133, 1848 ],[
-15, 75, -231, 61, -792 ],[
-20, 100, -308, 76, -1052]])

def get_diag(A):
    n=len(A[0])
    list=[] 
    lst_poly=[] 
    for i in range(n):
        if(A[i][i]!=1):
            p=A[i][i]/A[i][i].leading_coefficient()    
            list.append(p.list())
            lst_poly.append(p)
    return list,lst_poly

def prod_list(l):
    p=1
    for x in l:
        p=p*x
    return p

# Code pour l'EXERCICE

def inv_sim(M1):
    Delta1 =  (M1-x*matrix(QQ,[[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1]])).smith_form(transformation=false)
    Invariants1, lst_poly = get_diag(Delta1)
    Polmin1 = Invariants1[-1] 
    Polcar1 = prod_list(lst_poly)
    print("La forme normale de M1 est\n", Delta1)
    print( "\nLes invariants de similitude de M1 sont\n", Invariants1)
    print( M1.rational_form(format='invariants'))
    print( "\nLe polynôme minimal de M1 est ",Polmin1)
    print( "et d'après SageMath", M1.minimal_polynomial())
    print("Vérification p(M1)")
    print( Polmin1)
    print("\nLe polynôme caractéristique de M1 est ",Polcar1)
    print( "et d'après SageMath", M1.characteristic_polynomial())

inv_sim(M1)
inv_sim(M2)
inv_sim(M3)

print("""\
# ****************************************************************************
# FORME DE FROBENUIS D'UNE MATRICE Done
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

# idem exercice précédent


# Code pour l'EXERCICE

def frob(M):
    Delta1 =  (M1-x*matrix(QQ,[[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1]])).smith_form(transformation=false)
    Invariants1 = get_diag(Delta1)[1] 
    list_matrix =[companion_matrix(mt) for mt in Invariants1 ] 
    Frob1=matrix.block_diagonal(list_matrix)
    print("La forme de Frobenius de M1 est\n", Frob1)
    print( "vérification Sagemath \n", M1.rational_form())

# # Affichage des resultats

frob(M1)
frob(M2)
frob(M3)


print("""\
# ****************************************************************************
# FORME DE JORDAN D'UNE MATRICE Done
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

# idem exercice précédent

# Code pour l'EXERCICE
def jordan(M1):
    Delta1 =  (M1-x*matrix(QQ,[[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1]])).smith_form(transformation=false)
    Invariants1 = get_diag(Delta1)[1] 
    lst_diag=[]

    for pol in Invariants1:
        roots=pol.roots()
        for tup in roots:
            for i in range(tup[1]):
                lst_diag.append(tup[0])
    Jordan1= matrix.diagonal(lst_diag)
    print("La forme de Jordan de M1 est\n", Jordan1)
    print( "vérification Sagemath \n", M1.jordan_form())

jordan(M1)
jordan(M2)
jordan(M3)

reset()
print("""\
# ****************************************************************************
# BERLEKAMP-MASSEY
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

from sage.matrix.berlekamp_massey import berlekamp_massey

F2 = GF(2)
suite = [F2(1),0,1,1,0,0,0,0,1]
suite = suite+suite+suite+suite
ans = berlekamp_massey(suite)


# Code pour l'EXERCICE


# Donnees de l'enonce de l'exercice

from sage.matrix.berlekamp_massey import berlekamp_massey

F2 = GF(_sage_const_2 )
suite = [F2(_sage_const_1 ),_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ]
suite = suite+suite+suite+suite
ans = berlekamp_massey(suite)


# Code pour l'EXERCICE


def myBerlekampMassey(r):
    n = len(r)
    Fq = r[_sage_const_0 ].parent()
    PolFq = PolynomialRing(Fq, names=('x',)); (x,) = PolFq._first_ngens(1)
    c = PolFq(_sage_const_1 )
    l = _sage_const_0 
    c_star = PolFq(_sage_const_1 )
    d_star = Fq(_sage_const_1 )
    m = -_sage_const_1 
    for k in range(n) :
        somme = _sage_const_0 
        for i in range(_sage_const_1 , l + _sage_const_1 ) :
            somme += c[i]*r[k-i]
        d = r[k] + somme
        if d != _sage_const_0  :
            t = c
            c = c - d * (d_star)**(-_sage_const_1 )*c_star*x**(k-m)
            if l <= k/_sage_const_2  :
                l = k + _sage_const_1  - l
                c_star = t
                d_star = d
                m = k    
    return c,l
    

# # Affichage des resultats
print("Le plus petit LFSR de [101100001]^(inf) a pour polynome de connexion : ", myBerlekampMassey(suite)[_sage_const_0 ])

q=_sage_const_2 
Fq = FiniteField(q)
for _ in range(_sage_const_1 ):
    t=randint(_sage_const_1 ,10 )
    r = [Fq.random_element() for _ in range(t) ]
    r = r+r+r+r
    p1 = berlekamp_massey(r)
    p2,_ = myBerlekampMassey(r)
    if p1.reverse()- p2 !=_sage_const_0 :
        print("Erreur")


reset()
print("""\
# ****************************************************************************
# PERIODES D'UN LFRS Exercice 436
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

F2 = GF(2)
PolF2.<x> = PolynomialRing(F2)
chi1 = 1 + x + x^2 + x^3 + x^4
chi2 = 1 + x + x^2 + x^4
chi3 = 1 + x^3 + x^6

F5 = GF(5)
PolF5.<y> = PolynomialRing(F5)
chi4 = 3 + y^2
chi5 = 3 + 3*y + y^2


# Code pour l'EXERCICE

def BSGS(chi):
    PolFq = chi.parent()
    Fq = PolFq.base_ring()
    G = PolFq.quotient(chi)
    x = G.gen()
    n = G.order()
    m = ceil(n**(1/2))
    T = []
    e = G(_sage_const_1 )
    for j in range(m) :
        T.append(e)
        e = e * x
        if j > 0  and e == G(1 ) :
            return j
    h = x**(-m)
    gamma = h
    for i in range(1 , m) :
        for j in range(0 , m) :
            if gamma == T[j] :
                return i*m+j
        gamma = gamma * h        
    return 0 


# # Affichage des resultats

print("Période de chi1",  BSGS(chi1))
print("Période de chi2",  BSGS(chi2))
print("Période de chi3",  BSGS(chi3))
print("Période de chi4",  BSGS(chi4))
print("Période de chi5",  BSGS(chi5))


reset()
